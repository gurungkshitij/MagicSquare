# -*- coding: utf-8 -*-
"""Magic Square project: Kshitij

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Kfb4BoXngFVMY7Jo6V-k2q23om1n0ElC

#Magic Squares Project
### Kshitij Gurung, 05/11/2020

A n × n magic square is an arrangement of the numbers 1, 2, . . . , $n^2$ in a $n × n$ grid in such way
that all the rows, columns, and diagonals have the same sum.
In general, there are $n$ rows, $n$ columns, and
2 diagonals, for a total of $2n + 2$ sums. Each sum is equal to $n(n^2+1)/2$.

We are going to find the magic square by using stimulated annealing technique and study it's behaviour.

### Our procedure to get the magic square:
Use simulated annealing to find magic squares for at least n = 3 and n = 4. Here are some tips for setting up the problem:

• States: The states should be all possible arrangements of the numbers $1, 2, . . . , n^2$ in the $n × n$ grid.

• Starting State: Randomly assign the numbers $1, 2, . . . ,n^2$ to the grid.

• Function to Maximize: Define a function m(state) that indicates how far the row, column, and diagonal sums are from the desired value. You want to minimize m, so you want to maximize −m.

• Transitions: Randomly choose two entries in the grid and swap them.

• Stopping: Make your code stop when it finds a magic square.

We will be aiming to find magic square for $n = 3$, and $n = 4$, squares.

First of all, let's begin by importing some necessary libraries
"""

import numpy as np
import random
import math
import matplotlib.pyplot as plt
import warnings

"""This *state* function creates some random state from $1, 2, . . . , n^2$."""

def state(n):
  nsquare = n*n
  state = random.sample(range(1,nsquare+1), nsquare)
  return(state)

"""Creating some random states."""

firststate=(state(4)) # states for 4*4 square
print(firststate)
print(state(3)) # states for 3*3 square

"""Creating a function to fill in the grid with random states."""

def fillgrid(n, state):
  k = 0
  Grid =np.zeros((n,n), dtype=int) # creates an empty grid with all zero entries
  for i in range(n):
    for j in range(n):
      Grid[i,j]= state[k]
      k = k+1
  return(Grid)

"""Let's try filling in the $4*4$ and $3*3$ squares to check our functions."""

Grid=fillgrid(4,firststate)
print('4*4 grid:')
print(Grid) # 4*4 grid
print('3*3 grid:')
print(fillgrid(3,state(3))) #3*3 grid

"""We need a transition function that builds a proposal state by randomly alreting two entries from the current grid."""

def proposal(n,currState):
  state=currState.copy()
  indexes=random.sample(range(n*n), 2) # radomly pick two points from the grid.
  # switching the two entries around
  state[indexes[0]]=currState[indexes[1]]
  state[indexes[1]]=currState[indexes[0]]
  return(state)

"""Checking to make sure if it works."""

a=state(3)
print('current state',a)
print('proposal state',((proposal(3,a))))

a=state(4)
print('current state',a)
print('proposal state',((proposal(4,a))))

"""This is our main function that stimulates one step at a time. We have a *domove* function that calls maximizing *m* function and consider if we want to make a move to a proposal state."""

# function to maximize
def m(n, grid):
  # filling in the grid
  Grid = fillgrid(n, grid)
  #n = len(Grid) # length of rows
  desval = 0.5*n*(n**2+1) # ideal sum
  r = Grid.sum(axis=0)
  c = Grid.sum(axis=1)
  d1 = np.trace(Grid)
  d2 =sum(np.fliplr(Grid).diagonal())
  avgrc=np.append(r,c)
  d = np.append(d1,d2)
  avgs=np.append(avgrc,d)
  avgs = np.array(avgs)
  sabas = abs(avgs - desval)
  diff = max(sabas)
  return diff

# function to make one move of the random walk on the Markov chain
# MODIFIED TO RETURN (state, key) WHERE key INDICATES THE FOLLOWING:
#   0: moved to state with greater differenc from magic
#   1: moved to state with lower difference from magic
#   2: proposed state with greater difference but didn't move
def doMove1(n, currState, sig2):
  #print('current state',currState)
  if (m(n,currState)==0):
    raise Magic
  # propose a move
  propState = proposal(n,currState)
  # fill in the grid
  #print('proposed state', propState)
  # compute the change in values of h
  dh = m(n, currState) - m(n, propState) 

  # now decide whether or not to move to the proposed state
  if dh >= 0:  # then move
    #print("moving to state with smaller difference from the optimal avg sum")
    return (propState, 1)
  else:  # then maybe move
    #print("considering a move to state with higher diffence from the optimal avg sum")
    rho = math.exp((m(n,currState) - m(n,propState))/sig2) 
    # the bigger the prop state value the smaller would be rho, so less chances to travel to propstate. 
    #print('rho',rho)
    #rho =  m(n, currState)/ m(n, propState) 
    rand = random.random() # random number between 0 and 1
    #print('rand',rand)
    if rand < rho: # True with probability rho; False with probability 1 - rho
      #print("  moving")
      return (propState, 0)
    else: pass
      #print('not moving')
  
  return (currState, 2)

"""Let's find out if our funciton works properly."""

print(doMove1(4,firststate, 0.5))
print(doMove1(3, state(3),0.8))
print(doMove1(3, state(3),0.7))
print(doMove1(4, state(4),0.3))

"""We were successfully able to run a move for 4 states. In all four cases, we moved to a proposed state which had smaller difference (row, cols, and diagonals sums) to the magic square's optimal number.

Now, lets define a very important function that uses try and catch to run multiple steps, stops our algorithm when magic is found, and returns the numerber of steps it took to reach to the magic square.
"""

# define an exception that will be raised if percolation occurs
class Magic(Exception): pass

def findMagic(n, steps, sig2, deFac):
    
  numSteps = steps # number of steps to simulate
  sig2 = sig2         # starting value for sigma^2
  decFac = deFac  # decrease factor for sigma^2 after each step
  State = state(n)
  firstGrid = fillgrid(n, State)
  #print("starting state:", State)
  #print(firstGrid)

  try:
      # simulate the walk
    for i in range(numSteps):
      # take a step
      State, key = doMove1(n,State, sig2)
      # decrease sig2
      sig2 = sig2*decFac

  except Magic:
    # print("Magic square found", State)
    # print(fillgrid(n,State))
    # print(m(n, State))
    # return State
    # print(i)
    return i
  else:
    #print("No magic :( ")
    return np.nan

"""Making sure the funciton works."""

warnings.filterwarnings('ignore')
print('num steps to get 3*3 magic square:',findMagic(3, 500, 0.2,0.5))
print('num steps to get  4*4 magic square:',findMagic(4, 5000, 0.2,0.5))

"""Looks like it is working perfectly.

## 1. What values of sig2 and decFac did you find to work best?

First, we will apply a range of sigma2 values to our findmagic function. For each sig2, we will run 50 iterations of findmagic function with constant n:3, numstep iteration:500, and decFac: 0.99, and take their average to get the average number of steps it takes to reach Magic square for each sigma2 values.

First, let's try for $3*3$ square.
"""

sig2 = np.linspace(0.1,1.1,20)
stepsS=[]
# print("sigma2s:",sig2)
for i in sig2:
  stepsS.append(np.nanmean([findMagic(3, 500, i, 0.99) for j in range(50)]))
# print(stepsS)

plt.plot(sig2, stepsS)
plt.xlabel('Sig2')
plt.ylabel('Numsteps to Magic');

"""Looks like a lower sig2 value around 0.2, 0.25 could be a good choice.

Similarly, for each decFac, we will run 100 iterations of findmagic function with constant n:3, numstep iteration:500, and sig2: 0.25, and take their average to get the average number of steps it takes to reach Magic square for each decFac values.
"""

decFac = np.linspace(0.1,0.99,10)
stepsD=[]
print("decFac:",decFac)
for i in decFac:
  stepsD.append(np.nanmean([findMagic(3, 500, 0.25, i) for j in range(100)]))
print(stepsD)

plt.plot(decFac, stepsD)
plt.xlabel('decFac values')
plt.ylabel('Numsteps to Magic');

"""Looks like a lower decFac value around 0.35, 0.4 could be a good choice.

Therefore, based on my computation, sig2: 0.25, and decFac: 0.4 coule be the prefered choices.

### How about for $4*4$?
"""

sig2 = np.linspace(0.1,1.1,20)
stepsS=[]
# print("sigma2s:",sig2)
for i in sig2:
  stepsS.append(np.nanmean([findMagic(4, 2000, i, 0.99) for j in range(30)]))
# print(stepsS)
plt.plot(sig2, stepsS)
plt.xlabel('Sig2')
plt.ylabel('Numsteps to Magic');

"""For $4*4$, sig2 value around 0.5, 0.6 could be a good choice."""

decFac = np.linspace(0.1,0.99,10)
stepsD=[]
#print("decFac:",decFac)
for i in decFac:
  stepsD.append(np.nanmean([findMagic(4, 2000, 0.25, i) for j in range(30)]))
#print(stepsD)
plt.plot(decFac, stepsD)
plt.xlabel('decFac values')
plt.ylabel('Numsteps to Magic');

"""For $4*4$, decFac value around 0.5 could be a good choice.

## Using your preferred choice of sig2 and decFac, what is the average number steps required to find a magic square?

For $n:3$, sig2: 0.25 and decFac: 0.35 are the preferred choices.
"""

np.nanmean([findMagic(3,500, 0.25, 0.35) for i in range (100)])

"""Upon taking an average of 100 iterations, I found around 150 steps to be the average number steps to find a $3*3$ magic squared when using the prefererd sig2 and decFac.

For $n: 4$, I used sig2 as 0.55, decFac as 0.5, ran 100 iterations, and took the average to find the number of steps.
"""

np.nanmean([findMagic(4,2000, 0.55, 0.5) for i in range (100)])

"""986.76 was the avereage number of steps it took for $4*4$ square to attain the magic square.

## 3. How does the value of your function m change during the simulated annealing process? Make a plot that shows this clearly. Since the value changes more at the start of the process than at the end, a log scale on the horizontal axis may be helpful.

Let's tweak our function so that it returns the distance form the magic square.
"""

# function to maximize
def m(n, grid):
  # filling in the grid
  Grid = fillgrid(n, grid)
  #n = len(Grid) # length of rows
  desval = 0.5*n*(n**2+1) # ideal sum
  r = Grid.sum(axis=0)
  c = Grid.sum(axis=1)
  d1 = np.trace(Grid)
  d2 =sum(np.fliplr(Grid).diagonal())
  avgs=np.append(r,c)
  d = np.append(d1,d2)
  avgs=np.append(avgs,d)
  avgs = np.array(avgs)
  sabas = abs(avgs - desval)
  diff = max(sabas)
  return diff

# function to make one move of the random walk on the Markov chain
# MODIFIED TO RETURN (state, key) WHERE key INDICATES THE FOLLOWING:
#   0: moved to state with greater differenc from magic
#   1: moved to state with lower difference from magic
#   2: proposed state with greater difference but didn't move
def doMove2(n, currState, sig2):
  #print('current state',currState)
  if (m(n,currState)==0):
    raise Magic
  # propose a move
  propState = proposal(n,currState)
  # fill in the grid
  # compute the change in values of h
  dh = m(n, currState) - m(n, propState) 

  # now decide whether or not to move to the proposed state
  if dh >= 0:  # then move
    return (propState, 1, m(n, propState))
  else:  # then maybe move
    rho = math.exp((m(n,currState) - m(n,propState))/sig2) 
    # the bigger the prop state value the smaller would be rho, so less chances to travel to propstate. 
    rand = random.random() # random number between 0 and 1
    if rand < rho: # True with probability rho; False with probability 1 - rho
      return (propState, 0, m(n, propState))
    else: pass
  
  return (currState, 2, m(n, currState))

# define an exception that will be raised if percolation occurs
class Magic(Exception): pass

def findMagic2(n, steps, sig2, deFac):
  numSteps = steps # number of steps to simulate
  sig2 = sig2         # starting value for sigma^2
  decFac = deFac  # decrease factor for sigma^2 after each step
  State = state(n)
  #firstGrid = fillgrid(n, State)
  try:
      # simulate the walk
    distance=[]
    for i in range(numSteps):
      # take a step
      State, key, dist  = doMove2(n,State, sig2)
      distance.append(dist)
      # decrease sig2
      sig2 = sig2*decFac

  except Magic:
    return (distance)
  else:
    return (distance)

"""Checking out the fucntion and plot for $3*3$ grid."""

a=findMagic2(3,1000, .55,0.99)
plt.plot(range(1,len(a)+1), a)
# plt.xscale("log")
plt.xlabel("Number of Steps")
plt.ylabel("Distance from the magic square")
plt.title("Distance vs Number of steps");

"""The distance from magic slowly saturates towards 0 as the number of steps increases. However, the decreases is not linear as it seems to have some bumps up at places althought it ultimately climbs down. If we want the bumps can be minimised by choosing a smaller value of decFac.

How about for $4*4$ Grid.
"""

a = a=findMagic2(4,100000, 3,0.99)
plt.plot(range(1,len(a)+1), a)
plt.xscale("log")
plt.xlabel("Number of Steps")
plt.ylabel("Distance from the magic square")
plt.title("Distance vs Number of steps");

"""In case of $4*4$ square, it takes longer number of steps to decreases the distance from magic square to zero. Similary to previous case, the decay is not linear and has some ups and downs.

## Conclusion

- We saw that we can use stimulated annealing to find the magic square. 
- For $3*3$ square, with optimal sig2: 0.25 and decFac: 0.4, it took roghly 200 number of steps until it founds the magic square.
- For $4*4$ square, with optimal sig2: 0.55 and decFac: 0.5, it took roghly 985 number of steps until it founds the magic square.
- The preferred sig2 value for n: 3  was smaller (sig2=0.25) compared to for n: 4 (sig2=0.55). The preferred decFac was pretty much the same for both (around 0.5).
- The distance from the magic square decreases as the number of steps increases. Depending on the sig2 and decFac values, we can create either a monotonously decay line or some fluctuating decay line.

## Limitation and Future work

- Coming up with the maximizing function was tricky. The results were much consistent when we used the max instead of the sum in the maximizing function, even thought I initially thought the logic was same for both. This makes me wonder if there are other ways of defining maximizing function that is even more efficient. 
- The results were not as consistent as I had expected. In order to get a nice reliable average results, I wanted to run bigger iterations using bigger numsteps and bigger for loop ranges. However, it took lot of time to process the code which made it harder to achieve the optimal consistent result that I was looking for. In future, we could work on optimizing the code to run even faster, better, and to produce more consistent results.
- Sometimes it took more than 1000 steps for $3*3$ square to get to the magic square even thought the avereage steps were around 150. It would be interesting to investingate what are the probabilities associated with this odd phenomenan and investigae why that occurs.
"""